<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레인 피하기 게임</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            font-size: 1.2rem;
            color: #cbd5e1;
            margin-bottom: 2rem;
        }

        #gameCanvas {
            border: 4px solid #475569;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            display: block;
            margin: 0 auto;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
        }

        .overlay-content {
            text-align: center;
            padding: 2rem;
        }

        .overlay h2 {
            font-size: 3.5rem;
            margin-bottom: 1.5rem;
        }

        .overlay p {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .game-info {
            background: #1e293b;
            padding: 1rem 2rem;
            border-radius: 8px;
            margin-top: 1rem;
            text-align: left;
        }

        .game-info p {
            margin: 0.5rem 0;
            color: #94a3b8;
        }

        .stats {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .stat-box {
            background: #1e293b;
            padding: 1.5rem 2rem;
            border-radius: 12px;
            min-width: 200px;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .stat-value.current {
            color: #10b981;
        }

        .stat-value.best {
            color: #fbbf24;
        }

        .restart-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.3rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 1rem;
            transition: background 0.3s;
        }

        .restart-btn:hover {
            background: #059669;
        }

        .new-record {
            color: #fbbf24;
            font-size: 2rem;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>레인 피하기 게임</h1>
        <p class="instructions">↑↓ 방향키로 레인 이동 | 스페이스바로 시작</p>
        
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="1000" height="500"></canvas>
            
            <div id="menuOverlay" class="overlay">
                <div class="overlay-content">
                    <h2>게임 시작</h2>
                    <p style="font-size: 2rem; margin-bottom: 2rem;">스페이스바를 눌러 시작</p>
                    <p id="bestTimeDisplay" class="stat-value best"></p>
                    <div class="game-info">
                        <p>• 화살을 피하세요</p>
                        <p>• ↑↓ 방향키로 레인 이동</p>
                        <p>• 총 5개의 레인이 있습니다</p>
                        <p>• 시간이 지날수록 난이도가 증가합니다</p>
                    </div>
                </div>
            </div>

            <div id="gameOverOverlay" class="overlay hidden">
                <div class="overlay-content">
                    <h2 style="color: #ef4444;">게임 오버!</h2>
                    <p style="font-size: 2.5rem; margin-bottom: 1rem;">생존 시간: <span id="finalTime"></span>초</p>
                    <p id="recordMessage"></p>
                    <button class="restart-btn" onclick="startGame()">🔄 다시 시작 (스페이스바)</button>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">현재 시간</div>
                <div class="stat-value current" id="currentTime">0.00s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">최고 기록</div>
                <div class="stat-value best" id="bestTime">0.00s</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 500;
        const LANES = 5;
        const LANE_HEIGHT = CANVAS_HEIGHT / LANES;
        const PLAYER_X = 120;
        const PLAYER_SIZE = 40;

        let gameState = 'menu'; // 'menu', 'playing', 'dead'
        let playerLane = 2;
        let arrows = [];
        let time = 0;
        let bestTime = 0;
        let animationId = null;
        let lastSpawnTime = 0;
        let lastUsedLanes = [];
        let lastTime = 0;

        // Load best time from localStorage
        function loadBestTime() {
            const saved = localStorage.getItem('laneDodgeBestTime');
            if (saved) {
                bestTime = parseFloat(saved);
                updateBestTimeDisplay();
            }
        }

        function saveBestTime(newTime) {
            localStorage.setItem('laneDodgeBestTime', newTime.toString());
            bestTime = newTime;
            updateBestTimeDisplay();
        }

        function updateBestTimeDisplay() {
            document.getElementById('bestTime').textContent = bestTime.toFixed(2) + 's';
            const display = document.getElementById('bestTimeDisplay');
            if (bestTime > 0) {
                display.textContent = '최고 기록: ' + bestTime.toFixed(2) + '초';
            } else {
                display.textContent = '';
            }
        }

        function getLaneY(lane) {
            return LANE_HEIGHT / 2 + lane * LANE_HEIGHT;
        }

        function startGame() {
            gameState = 'playing';
            playerLane = 2;
            arrows = [];
            time = 0;
            lastSpawnTime = 0;
            lastUsedLanes = [];
            lastTime = 0;
            
            document.getElementById('menuOverlay').classList.add('hidden');
            document.getElementById('gameOverOverlay').classList.add('hidden');
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            gameLoop();
        }

        function endGame() {
            gameState = 'dead';
            
            document.getElementById('finalTime').textContent = time.toFixed(2);
            
            const recordMessage = document.getElementById('recordMessage');
            if (time > bestTime) {
                saveBestTime(time);
                recordMessage.innerHTML = '<span class="new-record">🏆 신기록!</span>';
            } else {
                recordMessage.innerHTML = '<p style="font-size: 1.5rem; color: #cbd5e1;">최고 기록: ' + bestTime.toFixed(2) + '초</p>';
            }
            
            document.getElementById('gameOverOverlay').classList.remove('hidden');
        }

        function spawnArrowWave() {
            // Determine arrow count based on time
            let arrowCount;
            if (time < 2) {
                arrowCount = 2;
            } else if (time < 5) {
                arrowCount = Math.random() < 0.5 ? 2 : 3;
            } else if (time < 10) {
                arrowCount = Math.random() < 0.4 ? 3 : 4;
            } else {
                arrowCount = Math.floor(Math.random() * 3) + 3; // 3-5
            }

            // Get available lanes
            let availableLanes = [0, 1, 2, 3, 4];
            
            // Filter out recently used lanes if possible
            if (lastUsedLanes.length > 0 && availableLanes.length > arrowCount) {
                availableLanes = availableLanes.filter(lane => !lastUsedLanes.includes(lane));
            }

            const currentWaveLanes = [];

            // Spawn arrows
            for (let i = 0; i < arrowCount; i++) {
                const randomIndex = Math.floor(Math.random() * availableLanes.length);
                const selectedLane = availableLanes[randomIndex];
                currentWaveLanes.push(selectedLane);
                availableLanes.splice(randomIndex, 1);

                if (availableLanes.length === 0) {
                    availableLanes = [0, 1, 2, 3, 4].filter(lane => !currentWaveLanes.includes(lane));
                }

                const arrow = {
                    x: CANVAS_WIDTH + 50 + (i * 60),
                    y: getLaneY(selectedLane),
                    lane: selectedLane,
                    speed: 8 + (time / 4),
                    id: Date.now() + Math.random() + i
                };
                
                arrows.push(arrow);
            }

            lastUsedLanes = currentWaveLanes;
        }

        function getSpawnInterval() {
            if (time < 3) return 600;
            if (time < 7) return 500;
            if (time < 12) return 400;
            if (time < 20) return 300;
            return 250;
        }

        function updateGame(deltaTime) {
            if (gameState !== 'playing') return;

            time += deltaTime;
            document.getElementById('currentTime').textContent = time.toFixed(2) + 's';

            // Spawn arrows
            if (time - lastSpawnTime > getSpawnInterval() / 1000) {
                spawnArrowWave();
                lastSpawnTime = time;
            }

            // Update arrows
            const playerY = getLaneY(playerLane);
            
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                arrow.x -= arrow.speed;

                // Check collision
                const dx = arrow.x - PLAYER_X;
                const dy = arrow.y - playerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < PLAYER_SIZE / 2 + 15) {
                    endGame();
                    return;
                }

                // Remove off-screen arrows
                if (arrow.x < -50) {
                    arrows.splice(i, 1);
                }
            }
        }

        function drawGame() {
            // Clear canvas with gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            bgGradient.addColorStop(0, '#1e293b');
            bgGradient.addColorStop(1, '#0f172a');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw lane lines
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 2;
            ctx.setLineDash([15, 8]);
            for (let i = 1; i < LANES; i++) {
                const y = i * LANE_HEIGHT;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw lane numbers
            ctx.fillStyle = '#475569';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < LANES; i++) {
                ctx.fillText(`${i + 1}`, 15, getLaneY(i) + 7);
            }

            if (gameState === 'playing') {
                const playerY = getLaneY(playerLane);
                
                // Draw player shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(PLAYER_X, playerY + PLAYER_SIZE / 2 + 8, PLAYER_SIZE / 2.5, PLAYER_SIZE / 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player body
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(PLAYER_X, playerY, PLAYER_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player eyes
                const eyeOffset = 9;
                const eyeSize = 6;
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(PLAYER_X - eyeOffset, playerY - 6, eyeSize, 0, Math.PI * 2);
                ctx.arc(PLAYER_X + eyeOffset, playerY - 6, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(PLAYER_X - eyeOffset, playerY - 6, eyeSize / 2, 0, Math.PI * 2);
                ctx.arc(PLAYER_X + eyeOffset, playerY - 6, eyeSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player mouth
                ctx.strokeStyle = '#065f46';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(PLAYER_X, playerY + 6, 10, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Draw arrows
                arrows.forEach(arrow => {
                    // Arrow glow
                    const gradient = ctx.createRadialGradient(arrow.x, arrow.y, 0, arrow.x, arrow.y, 25);
                    gradient.addColorStop(0, 'rgba(245, 158, 11, 0.8)');
                    gradient.addColorStop(1, 'rgba(245, 158, 11, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(arrow.x, arrow.y, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Arrow body
                    ctx.fillStyle = '#f59e0b';
                    ctx.strokeStyle = '#b45309';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(arrow.x - 25, arrow.y);
                    ctx.lineTo(arrow.x + 10, arrow.y - 12);
                    ctx.lineTo(arrow.x + 10, arrow.y + 12);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                });

                // Draw time on canvas
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.strokeText(time.toFixed(2) + 's', CANVAS_WIDTH / 2, 60);
                ctx.fillText(time.toFixed(2) + 's', CANVAS_WIDTH / 2, 60);
            }
        }

        function gameLoop(timestamp = 0) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (deltaTime < 0.1) { // Prevent huge jumps
                updateGame(deltaTime);
            }
            
            drawGame();
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'menu' || gameState === 'dead') {
                    startGame();
                }
            } else if (e.code === 'ArrowUp') {
                e.preventDefault();
                if (gameState === 'playing' && playerLane > 0) {
                    playerLane--;
                }
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                if (gameState === 'playing' && playerLane < LANES - 1) {
                    playerLane++;
                }
            }
        });

        // Initialize
        loadBestTime();
        drawGame();
    </script>
</body>
</html>